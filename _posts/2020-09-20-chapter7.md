---
layout: post
title: "Friends and Relations - Capítulo 7"
date: 2020-09-18
categories: Books
---
Friends and Relations

Outro capítulo maneiro, este sobre conjuntos.

Esse capítulo explora os conjuntos e a utilização de funções auxiliares para desenvolver os programas.

O que é um conjunto? Bom, no meu conhecimento básico, definiria conjunto como uma coleção de elementos únicos no qual a ordem não importa. Ou seja, (maça banana abacate mamão) é um conjunto, (banana, maçã abacate mamão) é o mesmo conjunto, pois a ordem não importa. E (maçã maçã pêra banana) não é um conjunto porque existem elementos repetidos.

Para fazer uma função que verifica se uma coleção de elementos é um conjunto, precisamos então verificar se cada elemento da lista é único.
```scheme
(define set?
  (lambda (l)
    (cond
      [(null? l) #t]
      [(member? (car l) (cdr l)) #f]
      [else (set? (cdr l))])))

(check-equal? (set? '(apple peaches apple plum))#f) ; elemento repetido: apple
(check-equal? (set? '(apple peaches pears plum)) #t)
```
 A função member já foi definida no capítulo 2


Para criar um conjunto a partir de uma lista, fazemos assim:

```scheme
(define makeset
  (lambda (lat)
    (cond
      [(null? lat) '()]
      [(member? (car lat) (cdr lat))
       (makeset (cdr lat))]
      [else (cons (car lat) (makeset (cdr lat)))])))
(check-equal? (makeset '(apple peach pear peach
                         plum apple lemon peach))
              '(pear plum apple lemon peach))

```

Outras funções legais são a que verifica se um conjunto é subconjunto do outro, `subset? s1 s2`, e a função de união e interseção. Deixarei a implementação delas aqui.
```scheme
(define subset?
  (lambda (set1 set2)
    (cond
      [(null? set1 ) #t]
      [(member? (car set1) set2)
       (subset? (cdr set1) set2)]
      [else #f])))
(check-equal? (subset? '(5 chicken wings)
                       '(5 hamburgers
                         2 pieces fried chicken and
                         light duckling wings)) #t)

(check-equal? (subset? '(4 pounds of horseradish)
                       '(four pounds chicken
                         and 5 ounces horseradish)) #f)
(define intersect
  (lambda (set1 set2)
    (cond
      [(null? set1) '()]
      [(member? (car set1 ) set2)
       (cons (car set1) (intersect (cdr set1) set2))]
      [else (intersect (cdr set1) set2)])))
(check-equal? (intersect '(stewed tomatoes and macaroni)
                         '(macaroni and cheese)) '(and macaroni))


(define union
  (lambda (set1 set2)
    (cond
      [(null? set1) set2]
      [(member? (car set1) set2) (union (cdr set1) set2)]
      [else (cons (car set1) (union (cdr set1) set2))])))

(check-equal? (union '(stewed tomatoes and macaroni casserole)
                         '(macaroni and cheese))
              '(stewed tomatoes casserole macaroni and cheese))
```
Por fim, os autores apresentam o conceito de par, que seria uma estrutura do tipo (a b), com a e b não nulos. Vou deixar aqui a definição da função `a-pair?` e vários exemplos

```scheme
(define a-pair?
  (lambda (l)
    (cond
      [(null? l) #f]
      [(atom? l) #f]
      [(null? (cdr l)) #f]
      [(null? (cdr (cdr l))) #t]
      [else #f])))

(check-equal? (a-pair? '(pear pear)) #t)
(check-equal? (a-pair? '(pear pear pear)) #f)
(check-equal? (a-pair? '(3 7)) #t)
(check-equal? (a-pair? '(full (house))) #t)
(check-equal? (a-pair? '((2) (pair))) #t)
```

Por fim, um bom exemplo da vantagem de usarmos funções auxiliares é a função que recebe uma lista de pairs e retorna cada par invertido. Bom, vamos para a implementação mais näive e depois para a que usa funções auxiliares

```scheme
(define revrel-naive
  (lambda (rel)
    (cond
      [(null? rel) '()]
      [else
        (cons
          (cons (car (cdr (car rel)))
                (cons
                (car (car rel)) '()) )
          (revrel-naive (cdr rel))
          )])))

(check-equal? (revrel-naive '((1 2) (3 4)))
              '((2 1) (4 3)))
```
Percebe a dificuldade de entender todos esses cons, cars e cdrs? Evite que seu código chege a esse nível e sempre busque abstrair os conceitos para serem mais fáceis de serem entendidos, mas se preocupe com isso realmente depois que você pensou na implementação mais simples.

Aqui está a função com funções auxiliares
```scheme
(define build-rev
  (lambda (a-pair)
    (cons (second a-pair) (cons (first a-pair) '()))))

(define revrel
  (lambda (rel)
    (cond
      [(null? rel) '()]
      [else (cons (build-rev (first rel))
                  (revrel (cdr rel)))])))

(check-equal? (revrel '((1 2) (3 4)))
              '((2 1) (4 3)))

```
Deste capítulo, foi isso que gostaria trazer. O próximo capítulo, o 8, trata das funções lambda. Sugiro bastante dar uma olhada!

