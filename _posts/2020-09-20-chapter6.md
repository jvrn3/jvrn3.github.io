---
layout: post
title: "Shadows - Capítulo 6"
date: 2020-09-18
categories: Books
---
Ocorreu um pequeno imprevisto no capítulo 6,7 e 8.
Eu havia lido os capítulos e feito os exercícios do livro, que são as perguntas. No entanto, aconteceu um probleminha que já acometeu todo usuário UNIX.
Fui apagar uma pasta e digitei `rm -rf * pasta`, e na verdade o correto seria `rm -rf pasta/*`. Como era uma pasta de 16 GB, achei que a demora era por isso, mas no fim deletou todos os arquivos pessoais do Linux. Alguns eu tinha backup, mas a maioria não. Enfim, tive que refazer os exercícios :(.

As primeiras perguntas são em relação a expressões aritméticas,e suas representações.

Qual é a reprentações que temos de expressões aritméticas? São algo do tipo: _3 + 4 * 5_ correto? Então vamos tratar de criar uma função que lê esses números e retorna o valor.

Primeiro precisamos de funções auxiliares.

```scheme
(define first
  (lambda (l)
    (car l)
    ))
(define second
  (lambda (l)
    (car (cdr l))))
(define third
  (lambda (l)
    (car (cdr (cdr l)))))

; exponencial
(define e
  (lambda (n x)
    (cond
      [(zero? x) 1]
      [else (* n (e n (sub1 x)))])))
  ```
  Essas já são suficientes para termos uma melhor abstração do problema

  Como verificamos se uma determinada expressão é válida? A nossa representação vai ser uma lista, na verdade uma S-Expression, que já estamos usando faz bastante tempo. Por exemplo, '(+ 2 3) representa uma S-expression e cada elemento é um átomo. Então, o '+ é diferente da função +, ela é só um símbolo.

  Para uma S-expression ser válida, ela deve respeitar as regras de uma expressão aritmética, no caso ser do tipo:
  - exp: número
  - exp: (numero op número)
  - exp: (exp op exp)

  No qual _número_ representa qualquer valor inteiro, _op_ representa a operação e _exp_ a expressão aritmética. Trataremos de apenas três operações aqui, adição(+), multiplicação(*) e exponencial(e).

  Em racket, podemos verificar se a expressão do tipo (exp op exp) é válida com seguinte função:
```scheme
(define numbered?
  (lambda (e)
    (cond
      [(atom? e) (number? e)]
      [(or (eq? (second e) '+)
           (eq? (second e) '*)
           (eq? (second e) 'e))
       (and (numbered? (first e)) (numbered? (third e)))])))

(check-equal? (numbered? '(1 + 3)) #t)
(check-equal? (numbered? '(1 + sausage)) #f)
(check-equal? (numbered? '(1 + (1 + 2))) #t)
```

Perceba o uso das funções auxiliares para não sobrecarregar de car e cdr.

Os autores apresentam o sétimo mandamento, que é o seguinte:
> Recorra nas subpartes que são da mesma natureza.
> - Nas sublistas de uma lista
> - Nas subepressões de uma expressão aritmética


Vamos para a definição mais legal por enquanto, que é a de realizar a leitura da expressão e retornar o valor
```scheme
(define val
  (lambda (x)
    (cond
      [(number? x) x]
      [(equal? (second x) '+)
       (+ (val (car x)) (val (third x)))]
      [(equal? (second x) '*)
       (* (val (car x)) (val (third x)))]
      [(equal? (second x) 'e)
       (e (val (car x)) (val (third x)))])))

(check-equal? (val '(3 + 2)) 5)
(check-equal? (val '(3 + 1)) 4)
(check-equal? (val '(3 + (1 + 1))) 5)
(check-equal? (val '(3 * (1 + 1))) 6)
(check-equal? (val '(3 * (2 e 2))) 12) ; 3 * 2^2
```

De brinque, temos outra implementação, mas nesse caso a expressão é do formato (op exp exp), conhecido como prefix notation, a que usamos em LISP
```scheme
(define val-left
  (lambda (exp)
    (cond
      [(number? exp) exp]
      [(equal? (first exp) '+)
       (+ (val-left (second exp)) (val-left (third exp)))]
      [(equal? (first exp) '*)
       (* (val-left (second exp)) (val-left (third exp)))]
      [(equal? (first exp) 'e)
       (e (val-left (second exp)) (val-left (third exp)))])))
(check-equal? (val-left '(+ 3 2)) 5)
(check-equal? (val-left '(+ 3 1)) 4)
(check-equal? (val-left '(+ 3 (+ 1 1))) 5)
(check-equal? (val-left '(* 3 (+ 1 1))) 6)
(check-equal? (val-left '(* 3 (e 2 2 ))) 12)
```
O legal de LISP é que essas funções são muito fáceis de implementar. Em apenas algumas linhas de código já podemos considerar que temos um interpretador de expressões aritméticas.

