---
layout: post
title:  "Oh my Gawd: It's full of stars! - Capítulo 5"
date:   2020-09-18 21:03:36 +0530
categories: Books
---

 Se você puder, tente dar uma olhada nas ilustrações do livro, são bem legais :).

 Esse capítulo trata de funções que recebem listas de listas.
 Por exemplo, a primeira pergunta é:
 ```
 O que é (rember* a l)?
 onde a é cup
 e l é ((coffee) cup ((tea) cup)
        (and (hick)) cup)

rember* é pronunciado como rember-star
 ```
 Então, o modo que estávamos usando até aqui vai ter que sofrer uma leve adaptação para percorrer as listas dentro de listas.

 Primeiro vou mostrar a implementação da _rember*_
 ```scheme
(define rember*
  (lambda (a l)
    (cond
      [(null? l) '()]
      [(list? (car l)) (cons (rember* a (car l))
                             (rember* a (cdr l)))]
      [(eq? a (car l)) (rember* a (cdr l))]
      [else (cons (car l) (rember* a (cdr l)))])))

(define L '(((tomato sauce))
            ((bean) sauce)
            (and ((flying)) sauce)))

(define E '(((tomato))
            ((bean))
            (and ((flying)))))

(check-equal? (rember* 'sauce L) E)
 ```

 Comparando a `rember` e `rember*` , percebemos que mais uma pergunta é feita, além de `(null?)` e `(eq?)`. No livro, o autor não utiliza `(list?)`, mas sim `(atom?)`, mas não faz diferença.
 Essa nova pergunta, `(list?)` serve para percorrer a lista interna, caso exista, fazendo duas chamadas recursivas: `(rember* a (car l)) e (rember* a (cdr l))`

 Agora temos o Primeiro Mandamento na versão finalizada

 ---
 > ## <center>Primeiro Mandamento (final)</center>
 > #### Quando se está recorrendo em uma lista de átomos, lat, faça duas perguntas: (null? lat) e else.
 > #### Quando se está recorrendo em um número n, faça duas perguntas: (zero? n) e else.
 > #### Quando se está recorrendo em uma lista de S-expressions l, faça três perguntas: (null? l), (atom? l) e else.

 ---
Temos a versão final do Quarto Mandamento também:
> ## <center>Quarto Mandamento</center>
 > #### Sempre mude pelo menos um argumento enquanto está fazendo recursão.

 > #### Em uma lista de átomos, lat, use (cdr lat);

 > #### Em um número, n, use (zero? n). Em S-expressions, l, use (car l) e (cdr l) se (null? l) e (atom? (car l)) *não* forem verdade.

 Aqui vai mais uma função que recorre em sublistas:
 ```scheme
(define subst*
  (lambda (new old l)
    (cond
      [(null? l) '()]
      [(list? (car l)) (cons (subst* new old (car l))
                             (subst* new old (cdr l)))]
      [(eq? (car l) old) (cons new (subst* new old (cdr l)))]
      [else
        (cons (car l) (subst* new old (cdr l)))])))

(define L-subst* '((banana)
                   (split ((((banana ice)))
                           (cream (banana))
                           sherbet))
                   (banana)
                   (bread)
                   (banana brandy)))
(define E-subst* '( (orange)
                   (split ((((orange ice)))
                           (cream (orange))
                           sherbet) )
                   (orange)
                   (bread)
                   (orange brandy)))

(check-equal?(subst* 'orange 'banana L-subst*) E-subst* )
 ```
 A lógica é a mesma, respeitando os mandamentos fica fácil de definir essas funções.

 Utilizando uma função que vimos no capítulo 4, podemos construir uma função que verifica se duas listas são iguais. O interessante é que a lista pode conter outras listas. Vamos para a definição e testes:
```scheme
(define eqlist?
  (lambda (l1 l2)
    (cond
      [(and (null? l1) (null? l2))
       #t]
      [(or (null? l1) (null? l2))
       #f]
      [(and
         (atom? (car l1))
         (atom? (car l2 )))
       (and (eqan? (car l1)
                   (car l2))
            (eqlist? (cdr l1)
                     (cdr l2)))]
      [(or
         (atom?
           (car l1))
         (atom? (car l2)))
       #f]
      [else
        (and
              (eqlist? (car l1)
                       (car l2))
              (eqlist? (cdr l1) (cdr l2)))
            ]
      )))
(check-equal? (eqlist? '() '()) #t)
(check-equal? (eqlist? '() '(1 2)) #f)
(check-equal? (eqlist? '(1 2) '(1 2)) #t)
(check-equal? (eqlist? '(1 2 (3 4)) '(1 2 (3 4))) #t)
(check-equal? (eqlist? '(3 4 (1 2)) '(1 2 (3 4))) #f)
```
Essa já é uma função um pouco maior, pois precisa fazer algumas comparações a mais porque ela recorre sobre duas listas ao mesmo tempo

Para facilitar ainda mais, podemos definir a função que compara igualdade, ainda mais genérica que a _equan?_, que aceita listas.

```scheme
(define equal?
  (lambda (x1 x2)
    (cond
      [(and (atom? x1)
            (atom? x2))
       (eqan? x1 x2)]
      [(or
         (atom? x1 )
         (atom? x2)) #f]
      [else
        (eqlist? x1 x2)])))
(check-equal? (equal? '() '()) #t)
(check-equal? (equal? '() '(1 2)) #f)
(check-equal? (equal? '(1 2) '(1 2)) #t)
(check-equal? (equal? '(1 2 (3 4)) '(1 2 (3 4))) #t)
(check-equal? (equal? '(3 4 (1 2)) '(1 2 (3 4))) #f)
(check-equal? (equal? 1 1) #t)
(check-equal? (equal? 1 2) #f)
```
Repare que essa função possui bastante testes, pois ela lida com muitas coisas diferentes. Perceba que quando a função lida com vários tipos de dados, o número de teste aumenta bastante!

Foi isso que gostaria de passar do capítulo 5. Sigamos para o Capítulo 6, no qual falaremos de um simples interpretador de expressões aritméticas!
