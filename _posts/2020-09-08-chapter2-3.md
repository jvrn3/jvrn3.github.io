---
layout: post
title: "Do it again, and again, and again..."
date: 2020-09-08
categories: Books
---

Vou falar aqui de dois capítulos, o 2 e o 3. Bora lá!

### Capítulo 2 - Do it, Do It Again, and Again, and Again...

Esse capítulo é bem curtinho e nos apresenta a noção de recursão.

Todos os exemplos aqui mostrados podem ser rodados em racket, apenas adicionando:

```scheme
#lang racket
(require rackunit)
```


Primeiramente nos é apresentada uma função, chamada de `(lat? l)`, que recebe uma lista l e verifica se ela é uma lista de átomos.

```scheme
(define lat?
  (lambda (x)
    (cond
      [(null? x) #t]
      [(atom? (car x)) (lat? (cdr x))]
      [else #f])))

; testes
(check-equal? (lat? '(Jack Sprat LOL)) #t)
(check-equal (lat? '((Jack) Sprat LOL)' #f))
```

Observação:

- comentários começam com ";"
- `check-equal` testa a função
- `cond` faz perguntas
- `lambda` cria funções
- `define` dá um nome à função

Outra função apresentada nesse capítulo é a `(member? a lat)`, no qual verifica se o átomo _a_ está em lat.

Definição:
```scheme
(define member?
  (lambda (a lat)
    (cond
      [(null? lat) #f]
      [else (or (eq? (car lat ) a)
                (member? a (cdr lat)))])))
; testes
(check-equal? (member? 'feijoada '(cafe cha agua)) #f)
(check-equal? (member? 'cafe '(acucar cafe agua pó)) #t)
```

***
<center><strong>IMPORTANTE</strong></center>



> ## Primeiro Mandamento (preliminar):
> ### Sempre pergunte `null?` como primeira pergunta nas funções.

***
Para uma melhor experiência, você pode baixar a [IDE DrRacket](https://racket-lang.org/) e rodar esses exemplos. Adicione as funções e rode exemplos com o stepper, botào que fica no canto superior direito.

Para rodar na linha de comando, baixe o [Racket](https://racket-lang.org/) no Sistema Operacional e rode no terminal `racket programa.rkt`



### Capítulo 3 - Cons the Magnificent

```scheme
; o que é (rember a lat)?
; onde a é moto
; e lat é
; (lanche moto hamburger geleia)
; Resposta: (lanche hamburger geleia)
```

Você consegue perceber o que a função rember faz?

Rember significa "remove member". Essa função remove o elemento _a_ de _lat_, no caso acima, retirou _moto_ da lista.

Você consegue implementar essa função? Pensando especialmente no primeiro mandamento e nas observações acima já é possível resolver esse problema. Vou implementar ela aqui com alguns testes para facilitar a visualização.

```scheme
(define rember
  (lambda (a lat)
    (cond
      [(null? lat) '()]
      [(eq? (car lat) a) (cdr lat)]
      [else (rember a (cdr lat))]
      )))
(check-equal? (rember 'bacon '(bacon lettuce and tomato))
              '(lettuce and tomato))
(check-equal? (rember 'and '(bacon lettuce and tomato))
              '(tomato))
```

Perceba pelo segundo teste que está retornando apenas _(tomato)_, você consegue identificar o erro? A função removeu todos os outros elementos, então ela está errada!

É aqui que aparece um nova palavra para a linguagen, a famosa _cons_.

***

> ## Segundo Mandamento
> ### Use _cons_ para construir listas.

***

~~Cons vem de construir lista. Brincadeira!~~

Para criar uma nova lista, usamos a palavra _cons_

Por exemplo, `(cons 1 '())` gera uma nova lista com o número 1

Arrumando a função para salvar os elementos anteriores, a nova função fica assim:
```scheme
(define rember-fixed
  (lambda (a lat)
    (cond
      [(null? lat) '()]
      [(eq? (car lat) a) (cdr lat)]
      [else
        (cons (car lat)
              (rember-fixed a (cdr lat)))])))
; is it working?
; if the test pass, it worked as expected
(check-equal? (rember-fixed 'and '(bacon lettuce and tomato))
              '(bacon lettuce tomato))
; xD
```

Por fim, temos o terceiro mandamento:

***
> ### Terceiro Mandamento
> #### Quando for construir uma lista, descreva o primeiro elemento típico e depois _cons_ ele com recursão natural.

***

No caso do _rember-fixed_, o primeiro elemento é (car lat) e a recursão natural é (rember-fixed a (cdr lat)).

Bom, por hoje é só isso que tenho para mostrar. Não estou detalhando perfeitamente os pontos do livro, estou apenas mostrando algumas anotações que fiz e que considero importante para absorver durante a leitura. Para um melhor entendimento, é imprescindível ler o livro e rodar os exemplos.

Até mais!

